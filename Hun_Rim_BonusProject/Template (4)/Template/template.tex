\documentclass[unicode,11pt,a4paper,oneside,numbers=endperiod,openany]{scrartcl}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{enumitem}

\newcommand{\norm}[1]{\lvert\lvert #1 \rvert\rvert}

\renewcommand{\thesubsection}{\arabic{subsection}}

\input{assignment.sty}
\begin{document}


\setassignment
\setduedate{Wednesday, 22 November 2023, 11:59 PM}

\serieheader{Numerical Computing}{2023}{\textbf{Student:} Hun Rim}{\textbf{Discussed with:} FULL NAME}{Bonus assignment}{}
\newline

\assignmentpolicy


\newpage

\section*{Exercise 1: Inconsistent systems of equations [10 points]}
Consider the following inconsistent systems of equations: \\

\begin{center}
(a) ${A_1x = b_1}$, where

\vspace{10px}

\begin{equation*}
A_1 =
\begin{bmatrix}
1 & 0 \\
1 & 0 \\
1 & 0
\end{bmatrix}
b_1=
\begin{bmatrix}
5 \\
2 \\
4
\end{bmatrix}
\end{equation*}
\end{center}

\begin{center}
(b) ${A_2x = b_2}$, where

\vspace{10px}

\begin{equation*}
A_2 =
\begin{bmatrix}
1 & 1 & 0 \\
0 & 1 & 1 \\
1 & 2 & 1 \\
1 & 0 & 1
\end{bmatrix}
b_2=
\begin{bmatrix}
2 \\
2 \\
3 \\
4
\end{bmatrix}
\end{equation*}
\end{center}

Find the least squares solution ${x^*}$ and compute the Euclidean norm of the residual, SE and RMSE. \\

\textbf{solution:} \\
Least Square solution ${x^*}$ can be obtained by solving the following equation:

\vspace{20px}

\begin{equation}
 A^TAx = A^Tb
\end{equation}

\vspace{20px}

Then from the ${x^*}$ obtained, we can get the residual vector as following and from it, we can calculate the Euclidean norm and proceed to SE (Sum of Square Residuals) and RMSE (Root Mean Squared Error):

\vspace{20px}

\begin{equation}
 r = Ax^* - b
\end{equation}

\vspace{20px}

\begin{equation}
 Euclidean Norm = \norm{r}_2
\end{equation}

\vspace{20px}

\begin{equation}
 SE = \norm{r}_2^2
\end{equation}

\vspace{20px}

\begin{equation}
 RMSE = \sqrt{\frac{SE}{m}}
\end{equation}

\vspace{20px}

Where ${m}$ is the number of rows in residual vector. \\

\newpage
(a)
\begin{equation*}
\begin{bmatrix}
1 & 1 & 1 \\
0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
1 & 0 \\
1 & 0 \\
1 & 0
\end{bmatrix}
x = \begin{bmatrix}
1 & 1 & 1 \\
0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
5 \\
2 \\
4
\end{bmatrix}
\end{equation*}
\begin{equation*}
 \begin{bmatrix}
  3 & 0 \\
  0 & 0
 \end{bmatrix}x=
 \begin{bmatrix}
  11 \\
  0
 \end{bmatrix}
\end{equation*}
\begin{equation*}
 x^* = \begin{bmatrix}
        3.6667 \\
        0
       \end{bmatrix}
\end{equation*}
\begin{equation*}
 r^* = \begin{bmatrix}
        1 & 0 \\
        1 & 0 \\
        1 & 0
       \end{bmatrix}
       \begin{bmatrix}
        3.6667 \\
        0
       \end{bmatrix} -
       \begin{bmatrix}
        5 \\
        2 \\
        4
       \end{bmatrix} =
       \begin{bmatrix}
        -1.3333\\
        1.6667 \\
        -0.3333
       \end{bmatrix}
\end{equation*}
\begin{equation*}
 EuclideanNorm = \norm{r}_2 = \sqrt{(-1.3333)^2 + (1.6667)^2 + (-0.3333)^2} = \sqrt{4.6667} \approx 2.1602
\end{equation*}

\begin{equation*}
 SE = \norm{r}_2^2 = (-1.3333)^2 + (1.6667)^2 + (-0.3333)^2 \approx 4.6667
\end{equation*}

\begin{equation*}
 RMSE = \sqrt{\frac{\norm{r}_2^2}{m}} \approx \sqrt{\frac{4.6667}{3}} \approx 1.2472 
\end{equation*}

(b)
\begin{equation*}
\begin{bmatrix}
1 & 0 & 1 & 1 \\
1 & 1 & 2 & 0 \\
0 & 1 & 1 & 1
\end{bmatrix}
\begin{bmatrix}
1 & 1 & 0 \\
0 & 1 & 1 \\
1 & 2 & 1 \\
1 & 0 & 1
\end{bmatrix}
x = \begin{bmatrix}
1 & 0 & 1 & 1 \\
1 & 1 & 2 & 0 \\
0 & 1 & 1 & 1
\end{bmatrix}
\begin{bmatrix}
2 \\
2 \\
3 \\
4
\end{bmatrix}
\end{equation*}

\begin{equation*}
 \begin{bmatrix}
  3 & 3 & 2 \\
  3 & 6 & 3 \\
  2 & 3 & 3
 \end{bmatrix}x = 
 \begin{bmatrix}
  9 \\
  10 \\
  9
 \end{bmatrix}
\end{equation*}

If we re-arrange the formula for ${x^*}$ we get:

\begin{equation}
 x^* = (A^T_2A_2)^{-1}A^T_2b_2
\end{equation}

and the resulting ${x^*}$ will be

\begin{equation*}
 x^* \approx \begin{bmatrix}
        2 \\
        -0.3333 \\
        2
       \end{bmatrix}
\end{equation*}

\begin{equation*}
 r = \begin{bmatrix}
1 & 1 & 0 \\
0 & 1 & 1 \\
1 & 2 & 1 \\
1 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
        2 \\
        -0.3333 \\
        2
\end{bmatrix} -
\begin{bmatrix}
2 \\
2 \\
3 \\
4
\end{bmatrix} \approx
\begin{bmatrix}
-0.3333 \\
-0.3333 \\
0.3333 \\
0
\end{bmatrix}
\end{equation*}

\begin{equation*}
 EuclideanNorm = \norm{r}_2 \approx \sqrt{(-0.3333)^2 + (-0.3333)^2 + (0.3333)^2 + (0)^2} \approx \sqrt{0.3333} \approx 0.5774
\end{equation*}

\begin{equation*}
 SE = \norm{r}_2^2 = (-0.3333)^2 + (-0.3333)^2 + (0.3333)^2 + (0)^2 \approx 0.3333
\end{equation*}

\begin{equation*}
 RMSE = \sqrt{\frac{\norm{r}_2^2}{m}} \approx \sqrt{\frac{0.3333}{4}} \approx 0.2887
\end{equation*}

\section*{Exercise 2: Polynomials models for least squares [20 points]}

\begin{enumerate}[label=(\alph*)]
 \item Write ${leastSquare.m}$ function which calculates least squares ${x^*}$, euclidean norm, SE and RMSE of a matrix A and vector b, and write a script ${ex2a.m}$ which computes the result of exercise 1.\\
 
  \begin{lstlisting}[language=Matlab]
  function [x, EuclideanNorm, SE, RMSE] = leastSquares(A, b)
    x = (A' * A) \ A' * b;
    r = A * x - b;
    EuclideanNorm = norm(r);
    SE = EuclideanNorm ^ 2;
    MSE = SE / length(b);
    RMSE = sqrt(MSE);
  end
 \end{lstlisting}
 
 The code above calculates least squares (${leastSquare.m}$) using matlab library function and Euclidean norm is calculated by using the matlab norm function after calculating the residual vector. Sum of Square Residuals (SE) are calculated by directly squaring the Euclidean norm, and before the Root Mean Squared Error (RMSE) is calculated, the Mean Squared Error is calculated through dividing SE by length of vector b. \\
 
 \begin{lstlisting}[language=Matlab]
    A_1 = [1, 0; 1, 0; 1, 0];
    b_1 = [5; 2; 4];
    A_2 = [1, 1, 0; 0, 1, 1; 1, 2, 1; 1, 0, 1];
    b_2 = [2; 2; 3; 4];

    [x_1, norm1, SE1, RMSE1] = leastSquares(A_1, b_1);
    [x_2, norm2, SE2, RMSE2] = leastSquares(A_2, b_2);
 \end{lstlisting}
 
 This particular code (${ex2a.m}$) defines the values of matrix A and vector b as given in the exercise 1, and it calculates and stores the least squares, Euclidean Norm, SE, RMSE using function in ${leastSquare.m}$ as described above. Result of the calculation via the script is same as the calculation by hand for (b) of exercise 1, but it differs for the (a). Reason behind this is because script calculation solves for least squares through utilizing inverse like shown in equation 6, whereas when calculating by hand, an algebric approach is taken. As determinant of ${x}$ is equal to 0, script generates ${NaN}$ and Euclidean Norm, SE, RMSE which are calculated from it also generates NaN. However, algebric approach evades this problem, hence, it produces normal result. A solution to this problem would be checking if least squares generated are ${NaN}$ and if true, we use built-in function such as ${pinv(A) * b}$ and otherwise we use the old inverse calculation approach. \\
 
 Debugged code is as following:
 \begin{lstlisting}[language=Matlab]
    determinant = det(A' * A);
    if (determinant == 0)
        x = pinv(A) * b;
    else
        x = (A' * A) \ A' * b;
    end
    r = A * x - b;
    EuclideanNorm = norm(r);
    SE = EuclideanNorm ^ 2;
    MSE = SE / length(b);
    RMSE = sqrt(MSE);
 \end{lstlisting}

 
 \item Consider the linear model ${y_i = \alpha_1 + \alpha_2x_i}$ and apply it to the crude oil and kerosene production data in the
period 1980-2011. Write a script ${linearModel.m}$ in which you use ${leastSquares()}$ to compute the
least squares solution ${x^*}$ and the metrics of the residual. For each dataset, create a figure in which you plot the original data points and the linear model. \\

 \begin{lstlisting}[language=Matlab]
    [year, production, ~] = readData(filePath);
    
    duration = 2011 - 1980 + 1;

    y = str2double(production);

    x = [ones(duration, 1), year(:)];

    [factors, ~, ~, ~] = leastSquares(x, y);

    z = factors(1) + factors(2) * year(:); %based on y = mx + b;
    
    % plot the line and scatter graph...
 \end{lstlisting}

The code above simply follows the process of reading the data from the file, then converting 'x' and 'y' to viable format of matrix A and vector b, and recaclulating the linear model (line graph) according to the least squares returned and plotting them with the origin (scatter graph). During conversion, columns of the matrix A filled with ${x_i^{columnNumber}}$ (columnNumber starts from 0, and there are only 2 columns) and 'y' is placed as vector b. \\
\vspace{20px}
 \begin{figure}[h!]
    \begin{minipage}[c]{1\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth]{./figures/ex2b.png}
    \end{minipage}
  \caption{Linear Model and original data of crude oil and kerosene production from 1980 to 2011}
\end{figure}
\vspace{20px}
\item Consider the quadratic model ${y_i = \alpha_1 + \alpha_2x_i + \alpha_3x^2_i}$ and apply it to the crude oil and kerosene production
data in the period 1980-2011. Write a script \textit{quadraticModel.m} in which you use \textit{leastSquares()} to
compute the least squares solution ${x^*}$ and the metrics of the residual. For each dataset, create a figure in which
you plot the original data points and the quadratic model.

The general flow of the logic is very similar, but the matrix A is extended via the same logic so it would produce bigger least square vector (there are 3 columns now). Then instead of ${y_i = mx_i + b}$, quadratic modelling equation ${y_i = a + bx_i + cx_i^2}$ is used. \\
\vspace{20px}
 \begin{lstlisting}[language=Matlab]
    same as before ...
    x = [ones(duration, 1), year(:), year(:).^2];

    [factors, ~, ~, ~] = leastSquares(x, y);

    z = factors(1) + factors(2) * year(:) + factors(3) * year(:).^2;
    same as before ...
 \end{lstlisting}
 \vspace{20px}
 As a result of that change, resulting graph (quadratic) became more fitting than the previous linear graph shown in figure 1.
 \vspace{20px}
 \begin{figure}[h!]
    \begin{minipage}[c]{1\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth]{./figures/ex2c.png}
    \end{minipage}
  \caption{Quadratic Model and original data of crude oil and kerosene production from 1980 to 2011}
\end{figure}
\vspace{20px}

\item Consider the cubic model ${y_i = \alpha_1 + \alpha_2 x_i + \alpha_3 x^2_i + \alpha_4 x^3_i}$ and apply it to the crude oil and kerosene production
data in the period 1980-2011. Write a script \textit{cubicModel.m} in which you use \textit{leastSquares()} to com-
pute the least squares solution ${x^*}$ and the metrics of the residual. For each dataset, create a figure in which you
plot the original data points and the cubic model.

We can apply the same approach as ${(c)}$ and just increase the size of least squares vector and change the slope calculation from ${y_i = a + bx_i + cx_i^2}$, to ${y_i = a + bx_i + cx_i^2 + dx_i^3}$

\newpage

Code can be altered as following: \\

\begin{lstlisting}[language=Matlab]
    x = [ones(duration, 1), year(1:duration), 
                            year(1:duration).^2, 
                            year(1:duration).^3];

    [factors, ~, ~, ~] = leastSquares(x, y(1:duration));

    z = factors(1) + factors(2) * year(1:duration)
                + factors(3) * year(1:duration).^2 
                + factors(4) * year(1:duration).^3;

\end{lstlisting}

Finally, the resultant graph would be more fitted to the original data points than other approaches. Especially for the crude oil production.\\

 \vspace{20px}
 \begin{figure}[h!]
    \begin{minipage}[c]{1\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth]{./figures/ex2d.png}
    \end{minipage}
  \caption{Cubic Model and original data of crude oil and kerosene production from 1980 to 2011}
\end{figure}
\vspace{20px}



\end{enumerate}



\section*{Exercise 3: Analysis of periodic data [20 points]}

\section*{Exercise 4: Data linearization and Levenberg-Marquardt method for the exponential model [20 points]}

\section*{Exercise 5: Tikhonov regularization [15 points]}



\end{document}
